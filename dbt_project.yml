# Name your project! Project names should contain only lowercase characters
# and underscores. A good package name should reflect your organization's
# name or the intended use of these models
name: 'my_new_project'
version: '1.0.0'
config-version: 2

# This setting configures which "profile" dbt uses for this project.
# In dbt Cloud this is handled by the connection, but "default" is fine.
profile: 'default'

# These configurations specify where dbt should look for different types of files.
# The `model-paths` config, for example, states that models in this project can be
# found in the "models/" directory.
model-paths: ["models"]
analysis-paths: ["analyses"]
test-paths: ["tests"]
seed-paths: ["seeds"]
macro-paths: ["macros"]
snapshot-paths: ["snapshots"]

target-path: "target"  # directory which will store compiled SQL files
clean-targets:         # directories to be removed by `dbt clean`
  - "target"
  - "dbt_packages"

# Configuring models
# Full documentation: https://docs.getdbt.com/docs/configuring-models
#
# Here we:
# - Set a default database & schema for all models
# - Add global pre/post hooks for query tagging + run audit (Snowflake)
# - Configure subfolders: staging, marts, semantic, example

models:
  my_new_project:
    # ðŸ”§ DEFAULTS FOR ALL MODELS IN THIS PROJECT
    # Adjust DATABASE and SCHEMA to match your Snowflake setup
    +materialized: view

    # ðŸ”¹ Global pre-hook: set a useful Snowflake QUERY_TAG for all models
    +pre-hook:
      - "ALTER SESSION SET QUERY_TAG = 'dbt:{{ this }}:{{ invocation_id }}';"

    # ðŸ”¹ Global post-hook: log each model run into an audit table (safe, append-only)
    # Make sure this table exists in Snowflake:
    #   CREATE TABLE ANALYTICS_DB.MONITORING.MODEL_RUN_AUDIT (
    #     MODEL_NAME      STRING,
    #     RUN_ID          STRING,
    #     RUN_AT          TIMESTAMP_LTZ,
    #     ROW_COUNT       NUMBER,
    #     MATERIALIZATION STRING
    #   );
    +post-hook:
      - >
        INSERT INTO ANALYTICS_DB.MONITORING.MODEL_RUN_AUDIT (
          MODEL_NAME,
          RUN_ID,
          RUN_AT,
          ROW_COUNT,
          MATERIALIZATION
        )
        SELECT
          '{{ this }}'       AS MODEL_NAME,
          '{{ invocation_id }}' AS RUN_ID,
          CURRENT_TIMESTAMP()   AS RUN_AT,
          COUNT(*)              AS ROW_COUNT,
          '{{ config.get("materialized") }}' AS MATERIALIZATION
        FROM {{ this }}

    # ðŸ“‚ STAGING LAYER (models/staging/)
    staging:
      +materialized: view

      # you can further nest, e.g. models/staging/finance/


    # ðŸ“‚ MARTS LAYER (models/marts/)
    marts:
      +materialized: table  # facts/dims as tables by default

    # ðŸ“‚ SEMANTIC LAYER FILES (models/semantic/)
    # YAML files defining semantic_models, metrics, saved_queries
    semantic:
      +materialized: view  # usually irrelevant; these are YAML-only

    # ðŸ“‚ EXAMPLE FOLDER (if you still use the starter example models)
    # Applies to all files under models/example/
    example:
      +materialized: table
